/* Auto-generated by genmsg_java.py for file /opt/ros/groovy/share/sensor_msgs/msg/MagneticField.msg */

package ros.pkg.sensor_msgs.msg;

import java.nio.ByteBuffer;

public class MagneticField extends ros.communication.Message {

  public ros.pkg.std_msgs.msg.Header header = new ros.pkg.std_msgs.msg.Header();
  public ros.pkg.geometry_msgs.msg.Vector3 magnetic_field = new ros.pkg.geometry_msgs.msg.Vector3();
  public double[] magnetic_field_covariance = new double[9];

  public MagneticField() {
  }

  public static java.lang.String __s_getDataType() { return "sensor_msgs/MagneticField"; }
  public java.lang.String getDataType() { return __s_getDataType(); }
  public static java.lang.String __s_getMD5Sum() { return "2f3b0b43eed0c9501de0fa3ff89a45aa"; }
  public java.lang.String getMD5Sum() { return __s_getMD5Sum(); }
  public static java.lang.String __s_getMessageDefinition() { return " # Measurement of the Magnetic Field vector at a specific location.\n" +
"\n" +
" # If the covariance of the measurement is known, it should be filled in\n" +
" # (if all you know is the variance of each measurement, e.g. from the datasheet,\n" +
" #just put those along the diagonal)\n" +
" # A covariance matrix of all zeros will be interpreted as \"covariance unknown\",\n" +
" # and to use the data a covariance will have to be assumed or gotten from some\n" +
" # other source\n" +
"\n" +
"\n" +
" Header header                        # timestamp is the time the\n" +
"                                      # field was measured\n" +
"                                      # frame_id is the location and orientation\n" +
"                                      # of the field measurement\n" +
"\n" +
" geometry_msgs/Vector3 magnetic_field # x, y, and z components of the\n" +
"                                      # field vector in Tesla\n" +
"                                      # If your sensor does not output 3 axes,\n" +
"                                      # put NaNs in the components not reported.\n" +
"\n" +
" float64[9] magnetic_field_covariance # Row major about x, y, z axes\n" +
"                                      # 0 is interpreted as variance unknown\n" +
"================================================================================\n" +
"MSG: std_msgs/Header\n" +
"# Standard metadata for higher-level stamped data types.\n" +
"# This is generally used to communicate timestamped data \n" +
"# in a particular coordinate frame.\n" +
"# \n" +
"# sequence ID: consecutively increasing ID \n" +
"uint32 seq\n" +
"#Two-integer timestamp that is expressed as:\n" +
"# * stamp.secs: seconds (stamp_secs) since epoch\n" +
"# * stamp.nsecs: nanoseconds since stamp_secs\n" +
"# time-handling sugar is provided by the client library\n" +
"time stamp\n" +
"#Frame this data is associated with\n" +
"# 0: no frame\n" +
"# 1: global frame\n" +
"string frame_id\n" +
"\n" +
"================================================================================\n" +
"MSG: geometry_msgs/Vector3\n" +
"# This represents a vector in free space. \n" +
"\n" +
"float64 x\n" +
"float64 y\n" +
"float64 z\n" +
""; }
  public java.lang.String getMessageDefinition() { return __s_getMessageDefinition(); }

  public MagneticField clone() {
    MagneticField c = new MagneticField();
    c.deserialize(serialize(0));
    return c;
  }

  public void setTo(ros.communication.Message m) {
    deserialize(m.serialize(0));
  }

  public int serializationLength() {
    int __l = 0;
    __l += header.serializationLength();
    __l += magnetic_field.serializationLength();
    __l += 72; // magnetic_field_covariance
    return __l;
  }

  public void serialize(ByteBuffer bb, int seq) {
    header.serialize(bb, seq);
    magnetic_field.serialize(bb, seq);

    for(double val : magnetic_field_covariance) {
      bb.putDouble(val);
    }
  }

  public void deserialize(ByteBuffer bb) {
    header.deserialize(bb);
    magnetic_field.deserialize(bb);

    int __magnetic_field_covariance_len = magnetic_field_covariance.length;;
    magnetic_field_covariance = new double[__magnetic_field_covariance_len];
    for(int __i=0; __i<__magnetic_field_covariance_len; __i++) {
      magnetic_field_covariance[__i] = bb.getDouble();
    }
  }

  @SuppressWarnings("all")
  public boolean equals(Object o) {
    if(!(o instanceof MagneticField))
      return false;
    MagneticField other = (MagneticField) o;
    return
      header.equals(other.header) &&
      magnetic_field.equals(other.magnetic_field) &&
      java.util.Arrays.equals(magnetic_field_covariance, other.magnetic_field_covariance) &&
      true;
  }

  @SuppressWarnings("all")
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    long tmp;
    result = prime * result + (this.header == null ? 0 : this.header.hashCode());
    result = prime * result + (this.magnetic_field == null ? 0 : this.magnetic_field.hashCode());
    result = prime * result + java.util.Arrays.hashCode(this.magnetic_field_covariance);
    return result;
  }
} // class MagneticField

